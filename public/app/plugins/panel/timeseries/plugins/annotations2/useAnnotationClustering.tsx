import { useMemo } from 'react';

import { DataFrame, FieldType } from '@grafana/data';

interface Props {
  annotations: DataFrame[];
  clusteringMode: ClusteringMode | null;
}

enum ClusteringMode {
  Hover = 'hover',
  Render = 'render',
}

const buildAnnotationClusters = (frame: DataFrame, timeVals: number[]) => {
  const isRegionVals: boolean[] =
    frame.fields.find((f) => f.name === 'isRegion')?.values ?? Array(timeVals.length).fill(false);
  const clusterIdx: Array<number | null> = Array(timeVals.length).fill(null);
  const clusters: number[][] = [];

  let thisCluster: number[] = [];
  let prevIdx = null;

  // 15min in millis
  // todo: compute this from pixel space, to make dynamic, like 10px -> millis
  const mergeThreshold = (3600 / 4) * 1e3;

  for (let j = 0; j < timeVals.length; j++) {
    let time = timeVals[j];

    // Don't cluster regions?
    if (!isRegionVals[j]) {
      if (prevIdx != null) {
        // if we're within the threshold
        if (time - timeVals[prevIdx] <= mergeThreshold) {
          // open cluster
          if (thisCluster.length === 0) {
            thisCluster.push(prevIdx);
            clusterIdx[prevIdx] = clusters.length;
          }
          thisCluster.push(j);
          clusterIdx[j] = clusters.length;
        } else {
          // close cluster
          if (thisCluster.length > 0) {
            clusters.push(thisCluster);
            thisCluster = [];
          }
        }
      }

      prevIdx = j;
    }
  }

  // close cluster
  if (thisCluster.length > 0) {
    clusters.push(thisCluster);
  }

  return { clusterIdx, clusters };
};
export const useAnnotationClustering = ({ annotations, clusteringMode }: Props) => {
  console.log('useAnnotationClustering');
  const { outAnnos } = useMemo(() => {
    console.log('useAnnotationClustering memo');
    const clusteredAnnotations: DataFrame[] = [];

    // per-frame clustering
    if (clusteringMode === ClusteringMode.Render) {
      for (let frameIdx = 0; frameIdx < annotations.length; frameIdx++) {
        const frame = annotations[frameIdx];

        // @todo annotation getters
        const timeVals: number[] = frame.fields.find((f) => f.name === 'time')?.values ?? [];
        const colorVals: string[] = frame.fields.find((f) => f.name === 'color')?.values ?? [];

        if (timeVals.length > 1) {
          let { clusterIdx, clusters } = buildAnnotationClusters(frame, timeVals);

          const timeEndFrame: DataFrame = {
            ...frame,
            fields: frame.fields
              .map((field) => ({
                ...field,
                values: field.values.slice(),
              }))
              // add new number field containing the cluster locations
              .concat({
                type: FieldType.number,
                name: 'clusterIdx',
                values: clusterIdx,
                config: {},
              }),
          };

          let hasTimeEndField = timeEndFrame.fields.findIndex((field) => field.name === 'timeEnd') !== -1;

          if (!hasTimeEndField) {
            timeEndFrame.fields.push({
              type: FieldType.time,
              name: 'timeEnd',
              values: Array(timeEndFrame.fields[0].values.length).fill(null),
              config: {},
            });
          }

          // append cluster regions to frame
          clusters.forEach((idxs, ci) => {
            timeEndFrame.fields.forEach((field) => {
              const vals = field.values;

              // @todo clean up
              if (field.name === 'time') {
                // Push the first clustered annotation as the annotation region start time
                vals.push(timeVals[idxs[0]]);
              } else if (field.name === 'timeEnd') {
                // push the last clustered annotation as the annotation region end time
                let lastIdx = idxs.length - 1;
                vals.push(timeVals[idxs[lastIdx]]);
              } else if (field.name === 'isRegion') {
                // It is a region
                // @todo can a cluster have just one anno?
                vals.push(true);
              } else if (field.name === 'color') {
                // Use the color of the first annotation in the region
                vals.push(colorVals[idxs[0]]);
              } else if (field.name === 'title') {
                // Indicate the cluster index as the annotation title
                vals.push(`Cluster ${ci}`);
              } else if (field.name === 'text') {
                // Merge the indicies as the text?
                // @todo debugging
                vals.push('idicies' + idxs.join(', '));
              } else if (field.name === 'clusterIdx') {
                // Update the cluster index?
                vals.push(ci);
              } else if (field.name === 'source') {
                // Update the source?
                vals.push(ci);
              } else if (field.name === 'tags') {
                // Update the tags?
                vals.push(ci);
              } else if (field.name === 'type') {
                // Update the type?
                vals.push(ci);
              } else {
                console.log('unexpected annotation field name', { field });
                vals.push(null);
              }
            });
          });

          // Set data frame length
          timeEndFrame.length = timeEndFrame.fields[0].values.length;
          clusteredAnnotations.push(timeEndFrame);
        } else {
          clusteredAnnotations.push(frame);
        }
      }
    } else if (clusteringMode === ClusteringMode.Hover) {
      // TODO
      console.warn('Hover mode not implemented');
    }

    return { outAnnos: clusteredAnnotations.length > 0 ? clusteredAnnotations : annotations };
  }, [annotations, clusteringMode]);

  return outAnnos;
};
